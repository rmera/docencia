'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docencia/docs/linux/guia_basica/historia/','title':"Historia",'content':"Algunas definiciones Nota: No todas estas definiciones son “canónicas”, si no que están en el contexto de esta guia.\n  Licencia: Cuando uno compra/obtiene un programa, al menos según la ley norteamericana, uno no lo compra realmente, si no que compra el derecho a usarlo y/o distribuirlo bajo ciertas condiciones. La licencia estipula esas condiciones.\n  Open source (codigo abierto)/Free software (software libre): Básicamente implican que el programa, documento u otra propiedad intelectual puede redistribuirse libremente, incluyendo la redistribucion de modificaciones o trabajos derivados (osea, un programa puede ser gratis, pero no open source, como el plugin de Flash para un navegador, u open source pero no gratis, aunque el mercado hace esto difícil). Otras exigencias pueden existir como crédito al autor original, o exigir que cualquier trabajo derivado sea también open-source. Algunas licencias libres u open-source populares son la BSD, la GPL del proyecto GNU, y las licencias “Attribution” y “Share-alike” the Creative Commons.\n  UNIX: Familia de sistemas operativos similares, uno de cuyos miembros es Linux (tecnicamente, cualquier sistema operativo que implemente un estandar conocido como POSIX).\n  Historia y arquitectura básica de UNIX UNIX es una familia de sistemas operativos similares y (hasta cierto punto) compatibles entre si. El UNIX original fue creado en los 70 por Ken Thompson (ken) y Dennis Ritchie (dmr) en los laboratorios Bell (actualmente, AT\u0026amp;T). Hoy en dia existen varios sistemas operativos de la “familia UNIX” que agrupa a FreeBSD, OpenBSD, Linux, Darwin (MacOS X), etc. Varios de estos son “libres” (software libre).\nComposición de un sistema UNIX (Kernel - Programas - Shell) Un sistema operativo UNIX consiste en varias partes que operan en forma orquestada, conforme a la filosofia UNIX descrita más adelante. Estas partes son.\n  Kernel o núcleo: El sistema operativo propiamente tal, el programa que comunica a la máquina con todos los otros programas. El kernel gestiona los recursos como memoria, tiempo de procesador, se asegura de que ningún programa “invada” el espacio de otro, termina (“mata”) programas cuando es necesario, etc.\n  Programas/librerías: Los programas que realizan las tareas que el usuario requiere, desde procesadores de texto, reproductores de video, visores moleculares, y las librerias que realizan tareas requeridas por estos programas, etc.\n  Interfaz de usuario o shell: Un programa o conjunto de ellos destinado a interaccionar con el usuario, transmitiendo su voluntad a los otros programas. Ejemplos de interfaces son entornos graficos (tipo windows) con los que uno interacciona principalmente con el mouse, y la interfaz de linea de comandos (“terminal”), en la que uno ingresa comandos que son transmitidos a programas. Normalmente, el nombre “shell” se usa solo para el segundo tipo de interfaz.\n  En el caso de Linux, el nombre corresponde al kernel, mientras que de las otras herramientas, una gran parte provenientes del proyecto GNU. Este sistema hibrido se denomina a veces GNU/Linux, pero llamarlo simplemente Linux es mas comun.\nDistribuciones de Linux Como lo que llamamos Linux es en realidad una mezcla del programa Linux con una variedad de herramientas, que suelen ser open source. muchas empresas y grupos de personas distribuyen versiones (distribuciones) de Linux con distintos instaladores del sistema, pequenas diferencias en las herramientas incluidas, y distintas formas de instalar programas. Algunas distribuciones populares son Ubuntu, Fedora, Debian, Red Hat y OpenSuse, Gentoo y Slackware. Algunas distribuciones incluyen software no-open source mientras otras son más estrictas. Las distribuciones mas usadas de Linux (hasta donde sé) son Ubuntu y Fedora. Ambas son recomendables para principiantes. La distribucion Linux Mint también es aconsejable.\nLa gente con deseos de aprender sobre el funcionamiento interno del sistema (y con la energia y tiempo para ello) puede probar Slackware, Gentoo o Arch. Las tres estan bien documentadas. Generalmente, uno no deberia empezar usando Linux con estas distribuciones, sino que deberia antes tener alguna experiencia con distribuciones de facil uso, como las mencionadas en el parrafo anterior.\nLa filosofia UNIX   Transparencia En UNIX toda la configuracion del sistema se hace mediante archivos de texto. Un usuario capaz no necesita nada mas que un editor de texto para modificar el comportamiento de cualquier parte del sistema. Asi mismo, los programas se comunican entre si mediante texto normal, legible por humanos.\n  Ortogonalidad: La filosofia UNIX consiste en dividir para triunfar. Un sistema Unix deberia funcionar con varios programas distintos, cada uno de los cuales cumple una funcion especifica, que se comunican entre sí mediante texto simple (como dijimos, legible por humanos). Estos programas operan en forma independiente.\n  Simplicidad/minimalismo: UNIX esta pensado para ser simple. Por esa razon, todo en UNIX se representa de la misma manera: Como un archivo. Archivos de texto y programas, por supuesto, pero tambien dispositivos (impresoras, webcams, discos duros) y hasta la informacion proporcionada por el kernel, el hecho de que UNIX puede configurarse directamente con archivos de texto, sin necesitar programas especiales, es parte tambien del minimalismo de UNIX. Notese que “simple” no significa “facil” (para el principiante al menos) y de hecho a veces ambos son excluyentes.\n  Estos preceptos son mas un ideal que algo que se cumpla en forma absoluta, sobre todo en la actualidad. Las distribuciones populares de Linux proporcionan varias herramientas (programas) para configurar el sistema, lo que puede hacer dificil configurarlo “a mano” (de hecho, imposible en distribuciones salvo Slackware, Gentoo y otras excepciones). Incluso en el UNIX “original” existen herramientas que violan algunos de estos preceptos.\n Copyright (c) Raul Mera A.\nTodo el contenido de esta wiki está bajo una Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional\n"});index.add({'id':1,'href':'/docencia/docs/estadistica/bayes_no_tecnica/','title':"Bayes no tecnica",'content':"El Teorema de Bayes (para publico general) En esta pagina trato de explicar el teorema de Bayes de forma no tecnica, con la menor cantidad de matematicas posibles.\nImaginemos que tenemos 3 bolsitas distintas de M\u0026amp;M:\n Con 10 dulces rojos, y 10 verdes (total: 20). Con 5 duces azules y 10 verdes (total: 15) Con 5 dulces rojos, 3 azules, y 1 verde (total: 9)  El total de de dulces va a ser: 15 rojos, 8 azules, 21 verdes (total: 44).\nEso significa, que si sacamos un dulce de una bolsita, pero no sabemos de cual estamos sacando, la probabilidad de sacar un dulce rojo es de 15 entre 44 (15/44 = 0.34 = 34%) La probabilidad de sacar un dulce azul es de 8 entre 44 (8/44 = 0.18 = 18%) y la probabilidad de sacar un dulce verde es de 21 entre 44 (21/44 = 0.48 = 48%). En lenguaje estadistico, esas tres probabilidades se escriben de esta forma:\n P(rojo) = 0.34 = 34% P(azul) = 0.18 = 18% P(verde) = 0.48 = 48%  Si sabemos de que bolsita estamos sacando el dulce, la probabilidad de sacar uno de un color dado, cambia! por ejemplo, si sabemos que estamos sacando de la bolsita 3, la probabilidad de sacar un dulce rojo es de 5 entre 9 (5/9 = 0.56 = 56%), bastante mas alta que el 34% si no sabemos de que bolsita se trata.\nProbabilidad condicional La probabilidad de la que hablamos en el parrafo anterior, es decir, la probabilidad de sacar un dulce rojo si sabemos que estamos sacando de la bolsa 3, se llama probabilidad condicional. Es la probabilidad de que algo ocurra con la condicion de que otra cosa ya haya ocurrido (en este caso, con la condicion de que hayamos seleccionado la bolsa 3). En lenguaje estadistico, la probabilidad de que algo ocurra si es que una condicion se cumple se escribe\n P(algo|condicion)  Por ejemplo, la probabilidad de sacar un dulce rojo si sabemos que sacamos de la bolsa 3 se podria escribir P(rojo|bolsa3). Esa forma de escribir la probabilidad condicional es importante, por que nos permite ahorrar mucho espacio, y la vamos a usar mas abajo. Detente un poco en esta seccion para asegurarte de que la recuerdas!\nEl teorema de Bayes Como vimos, la probabilidad condicional es muy facil de calcular en el caso anterior. Pero que pasa si queremos calcular la probabilidad opuesta? Es decir, sacamos un dulce de una bolsa cualquiera, y el dulce resulta ser azul. Sabiendo esto, cual es la probabilidad de que hayamos sacado de la bolsa 3? Es decir, cual es la probabilidad de haber elegido la bolsa 3 con la condicion de que el dulce que obtuvimos sea azul? O en lenguaje estadistico: P(bolsa3|azul). Aca la cosa se complica un poco.\n  Intuitivamente podemos decir que es imposible que la bolsa haya sido la 1, es decir, la probabilidad es cero para esa bolsa, P(bolsa1|azul)=0\n  Tambien podemos decirque es mas probable que la bolsa de donde salio el dulce azul sea las 2 que la 3 (porque hay mas dulces azules en la bolsa 2). P(bolsa2|azul) \u0026gt; P(bolsa3|azul).\n  Calcular el numero exacto de la probabilidad parece mas dificil! Bueno, aca es donde entra el teorema de Bayes. El teorema de Bayes nos permite calcular una probabilidad condicional, si es que conocemos la probabilidad condicional opuesta Es decir, nos permite saber la P(bolsa2|azul) si conocemos P(azul|bolsa2) Esta ultima es muy facil de obtener, como ya vimos. Entonces, veamos la formula del teorema de Bayes, especificamente para nuestro problema. Sin asustarse! vamos a explicar cada parte:\n  Ya sabemos lo que significa buena parte de la formula. P(bolsa2|azul) es lo que queremos calcular y P(azul|bolsa2) es un dato conocido (0.33 o 33%. Entiendes por que?).\n  P(bolsa2) es lo que se llama probabilidad a priori. Es la probabilidad de elegir la bolsa 2 en general, antes de tener ningun dato sobre el color del dulce que sacamos. En este caso, el valor para esta probabilidad es simplemente 1 entre 3 (1/3 = 0.33 = 33%), porque si no sabemos nada mas, no hay ninguna razon para pensar que una bolsa es mas probable que la otra.\n  P(azul) Es simplemente la probabilidad de sacar un dulce azul, independiente de la bolsa (o, que es lo mismo, sin saber de que bolsa viene). Eso lo calculamos al principio de este articulo, cierto? es 8 entre 44 (8/44 = 0.18 = 18%).\n  Entonces, tenemos todo! Reemplacemos los valores en la formula, y hagamos el calculo.\nSi sacamos un dulce azul, la probabilidad de que viniera de la bolsa 2 es de 0.6, o de un 60%. Esto calza con nuestra intuicion de P(bolsa2|azul) = P(bolsa3|azul).\nDiscusion El teorema de Bayes es muy practico, no es un \u0026ldquo;problema de libro de matematicas\u0026rdquo;. Nos permite estimar, hacernos una idea racional sobre el mundo y, por tanto, tomar decisiones racionales. La forma en que normalmente se comprende el teorema de Bayes es que, tenemos una idea preeliminar (o a priori) de cual es la probabilidad de que algo suceda, y luego de obtener datos que no teniamos, usamos estos datos para \u0026ldquo;actualizar\u0026rdquo; nuestra idea. En el caso del ejemplo, nuestra idea a priori o preeliminar era que es igualmente probable elegir cualquiera de las 3 bolsitas (porlo que la probabilidad de haber elegido la bolsa dos era de 1 entre 3, 1/3 = 0.33 = 33%). Pero una vez que sacamos el dulce, y vemos que es azul, utilizamos este dato para actualizar nuestra idea, llegando a la conclusion de que la probabilidad de haber elegido la bolsa azul es de 0.6, o 60%.\nAlgunas aplicaciones posibles:  Una aplicacion muy interesante es saber si algo que nos dicen los medios o las autoridades (que corresponderia a nuestra idea previa, o a priori, en nuestro ejemplo anterior, a P(bolsa2)) es cierto o falso, considerando los datos que hemos obtenido, y que sabemos que son ciertos (en nuestro ejemplo, sabemos que sacamos un dulce azul).\nPor ejemplo, todavia al inicio de la epidemia de COVID19 (el 9 de febrero), se informaba que era una enfermedad muy letal, y que un 3-4% de los enfermos fallecian. Ese es un numero altisimo, considrando que la gripe porcina de 2009 tuvo una fatalidad menor al 0.1%. Sin embargo, fuera de China continental, el numero de casos totales era de 370 en ese momento, y una persona fallecida (segun esta pagina ). Cual es la probabilidad de que haya algo \u0026ldquo;raro\u0026rdquo; con la informacion de China continental? En ese caso, queremos calcular la probabilidad de que la mortalidad sea efectivamente de 4%, dado que en fuera de China hay 370 casos y un fallecido. Nuestra creencia a priori podemos dejarla en 50% (ni confiamos ni desconfiamos de la informacion oficial). La probabilidad de encontrar 1 fallecido en 370 casos se saca de una funcion matematica, que no vamos a discutir aqui (para un ejemplo similar,tratado con detalle, vean esta pagina de la wiki ), pero que es la misma funcion que se usa para calcular la probabilidad de sacar 5 caras al tirar una moneda 30 veces, si la moneda no tiene truco (es decir, si hay un 50% de probabilidad de sacar cara, cada vez).\nLa respuesta es que era muy probable que hubiera algo raro. Que pasaba? No era el caso que el gobierno chino ocultara informacion. Ahora sabemos que lo que parece haber ocurrido es que la fatalidad es de 3-4% si y solo si el sistema de salud colapsa. China, al principio, fue tomada por sorpresa y sus sistema de salud colapso, mientras que, fuera de China, habia pocos casos, por lo que el sistema de saludo podia brindar atencion a todo el mundo. Rapidamente, sin embargo, China fue capaz de recuperarse.\nSe les ocurre alguna otra aplicacion del teorema de Bayes? Piensenla un poco, seguro que van a encontrar!\n Pd. Como siempre, la falta de tildes se debe a mi teclado en ingles :-)\n"});index.add({'id':2,'href':'/docencia/docs/estadistica/','title':"Estadistica",'content':"Para que estadistica? La estadistica es la ciencia que estudia la prediccion del futuro, y la toma de decisiones racionales dada una cantidad de datos.\nTodos, en nuestras vidas, nos vemos enfrentados la necesidad de estimar la probabilidad de que un evento futuro ocurra (o no) y a la nececidad de tomar decisiones basadas en informacion.\nLos estudiantes de ciencia, con mayor razon requieren un conocimiento de estadistica, pues, cualquiera que sea el area en la que se desempenen, en la ciencia se proponen y validan o falsan hipotesis con base en resultados experimentales. El analisis de estos resultados, y la prediccion de la probabilidad de que nuestra hipotesis haya sido falsada por ellos es un tema de interes para cualquier estudiante de ciencia.\nEspero ir agregando a esta seccion informacion que sirva para ayudar a comprender y aplicar algunos conceptos de la estadistica.\nHasta ahora, los contenidos de esta seccion son:\n Teorema de Bayes (para el publico general) Teorema de Bayes y una aplicacion a COVID-19 (para estudiantes de ciencia)  "});index.add({'id':3,'href':'/docencia/docs/programacion/','title':"Programacion",'content':"Sin importar el area de la ciencia en la que quieran trabajar, seguramente va a involucrar estas coas:\n El uso de un computador El analisis de datos Tareas repetitivas como buscar algo en un archivo de texto  Programar (es decir, escribir programas que luego se ejecuten en un computador) nos ayuda a aprovechar el punto 1 para resolver los problemas derivados de los puntos 2 y 3.\nQue significa escribir un programa? Basicamente, significa escribir, en un archivo de texto, instrucciones precisas, paso por paso, para una tarea que queremos que el computador realice.\nEl principal factor, es que necesitamos escribir estas instrucciones de forma tal que el computador las \u0026ldquo;entienda\u0026rdquo;.\nLas instrucciones que el computador \u0026ldquo;entiende\u0026rdquo; nativamente son muy basicas: mover numeros entre una memoria y otra, sumarlos, restarlos, y similar. Si quisieramos escribir directamente en el lenguaje del computador (que se llama lenguaje de maquinas) tendriamos que expresar todo lo que queremos hacer en terminos de mover contenido de memoria, sumar, restar y similar.\nPor supuesto, eso seria muy dificil. Afortunadamente, hay gente que ha escrito programas que nos permiten escribir nuestras instrucciones en un lenguaje mas similar a nuestro lenguaje natural, para que despues sean \u0026ldquo;traducidas\u0026rdquo; al lenguaje de maquinas. Estos programas se llaman \u0026ldquo;compiladores\u0026rdquo; o \u0026ldquo;interpretes\u0026rdquo; (ya vamos a ver la diferencia entre ambos tipos).\nDistintas personas han escrito distintos \u0026ldquo;traductores\u0026rdquo; (compiladores/interpretes) entre diferentes lenguajes de programacion y el lenguaje de maquinas. Generalmente, mientras el lenguaje mas se parezca a nuestro lenguaje natural se dice que es de mas alto nivel mientras que de los lenguajes mas similares al lenguaje de maquinas se dice que son de bajo nivel. Sobre-simplificando, podemos decir que es mas facil escribir programas en lenguajes de alto nivel, mientras que los de bajo nivel producen programs mas eficientes.\nEn este articulo vamos a estudiar un lenguaje de programacion de alto nivel, y muy simple llamado AWK (por las iniciales de sus creadores). La razon es que es un lenguaje pequeno, por lo que podemos aprender un buen porcentaje de el en poco espacio, y porque esta hecho para automatizar algo que casi todos tenemos que hacer alguna vez: Procesar archivos de texto.\nVamos a aprender AWK!\n"});index.add({'id':4,'href':'/docencia/docs/programacion/awk/','title':"Programacion Basica en AWK",'content':"Maniuplando archivos de texto con AWK. Esta pagina puede parecer un poco larga, pero no lo es tanto si consideran lo que van a aprender. Es un lenguaje de programacion, especialmente disenado para automatizar una de las tareas mas comunes (y tediosas) a los que todos (no solamente los cientificos) nos enfrentamos: Manipular archivos de texto. Aca vamos a ver solamente algunas caracteristicas basicas AWK, pero suficientes para escribir programas utiles.\nPor ahora, mis ejemplos pueden ser poco realistas, pero a medida que vemos algunas caracteristicas mas avanzadas de AWK, vamos a ser capaces de enfrentar problemas \u0026ldquo;del mundo real\u0026rdquo;. Veamos las siguientes situaciones de ejemplos:\n  Tenemos un grupo de 500 secuencias de proteina en formato FASTA. Sabemos que 200 de estas secuencias contienen la subsecuencia AAEGGEAAH, necesitamos encontrarlas y ponerlas en un nuevo archivo.\n  En nuestra labor docente, tenemos las notas de 3 pruebas para 100 estudiantes, con sus respectivos nombres, en un archivo de texto separado por espacios. Queremos saber quienes de ellos tienen promedio menor o igual a 4, para tratar de determinar por que tienen problemas en el curso.\n  Tenemos las coordenadas de una molecula en formato PDB (protein data bank), las queremos en el formato XYZ (utilizado por programas de mecanica cuantica).\n  En estos tres problemas, necesitamos extraer informacion de archivos de texto, en los que cada linea esta dividida en \u0026ldquo;campos\u0026rdquo; Por ejemplo. Cada linea del ejemplo 2 tiene varios \u0026ldquo;campos\u0026rdquo;: nombre, apellido, nota 1, nota 2 y nota 3, separados por espacios.\nAWK es un lenguaje de programacion pensado especialmente para este tipo de trabajos. Si bien puede utilizarse para distintas cosas, los programas escritos en AWK que solucionan problemas como los de los ejemplos suelen ser muy breves, a veces, una sola linea de codigo.\nPara aquellos de Uds. que tengan Linux instalado en sus computadoras, AWK viene de seguro como parte del sistema. Aunque no estoy completamente seguro, creo que ese es tambien el caso para los usuarios de MacOS. Los usuarios de Windows deberan descargar una version compatible (el software es \u0026ldquo;libre\u0026rdquo; y gratuito, por lo que no deberia ser dificil de encontrar).\nEl lenguaje En el caso mas simple, un programa en AWK no es mas que un comando que se ejecuta para cada linea de un archivo.\nEl siguiente programa:\n{print}\nImprimira todas las lineas del archivo en cuestion. Para lograr que AWK ejecute nuestro programa, \u0026ldquo;llamamos\u0026rdquo; al interprete con el comando \u0026ldquo;awk\u0026rdquo;, seguido del programa (o del archivo que contiene al programa) y del nombre del archivo a procesar. Si nuestro archivo se llama archivo.txt, el comando completo seria:\nawk '{print}' archivo.txt\nPor supuesto, ese no es un programa muy util. Un programa en AWK un poco menos simple, pero mas util tiene la siguiente estructura:\npatron1 {accion1};patron2 {accion2}\nPara cada linea de nuestro archivo, AWK evaluara si el patron1 se cumple. En ese caso, realizara la accion1. Luego, AWK evaluara si patron2 se cumple. En ese caso, realizara accion2 Podemos definir tantos pares accion - patron como queramos. Tambien podemos definir una accion vacia, sin patron, como en el ejemplo anteiror (en el que todo el programa es la accion \u0026lsquo;{print}'. Una accion sin patron se realiza en todas las lineas.\nConsideremos el problema del primer ejemplo. Un archivo que contiene una secuencia de aminoacidos en cada linea, y contiene 500 lineas de interes en total. Queremos imprimr las secuencias que contentan la subsecuencia AAEGGEAAH. Una solucion probablemente aceptable (aunque no optima), la entrega el siguiente programa en AWK:\n/AAEGGEAAH/ {print NR, $0}\nQue ejecutariamos asi:\nawk '/AAEGGEAAH/ {print NR, $0}' secuencias.fasta\nEn este caso el patron es encontrar la secuencia de texto AAEGGEAAH en la linea (las barras inclinadas al rededor de un texto indican que el patron es cierto si el texto se encuentra en la linea). Si el patron se cumple, la accion es imprimir el numero de linea (NR) y la linea completa $0.\nAca observamos el primer uso de variables. Las variables son \u0026ldquo;cajitas\u0026rdquo; con nombre que contienen un valor.\nCuando AWK ejecuta un programa, lee el archivo en cuestion linea por linea. Para cada linea que lee, asigna el numero de la linea a la variable NR (es decir, la \u0026ldquo;cajita\u0026rdquo; NR pasa a contener el numero de la linea) y asigna la linea misma a la variable $0. Esas no son todas las variables que asigna! Ademas, al leer cada linea, la separa en \u0026ldquo;campos\u0026rdquo; separados por espacios (por defecto, mas adelante veremos como cambiar el separador). El primera campo queda guardado en la variable $1, el segundo en la variable $2, el tercero en la variable $3 y asi, tantos campos como tenga la linea en cuestion.\nConsiderando la informacion del parrafo anterior, es facil crear un programa en AWK para resolver el problema del ejemplo 2. Imaginemos que cada linea del archivo es como la siguiente:\n\u0026lsquo;Apellido Nombre nota1 nota2 nota3\u0026rsquo;\nEl siguiente programa en AWK imprimira solamente las lineas de aquellos estudiantes con promedio menor o igual a 4.0.\nawk '($4+$5+$6)/3 \u0026lt;= 4.0 {print $0, ($4+$5+$6)/3}' notas.dat\nNotese que incluyo el comando completo. El programa per se es solamente la parte entre comillas.\nQue hace este programa?\nPara cada linea, analiza si el patron ($4+$5+$6)/3 \u0026lt;= 4.0 se cumple. El patron dice, la suma de los campos 4, 5 y 6 dividida por 3 debe ser menor o igual que 4.0. \u0026lsquo;\u0026lt;=\u0026rsquo; es la forma en que \u0026ldquo;menor o igual\u0026rdquo; se escribe normalmente en programacion.\nPusto que los apellidos y el nombre ocupan los 3 primeros campos, las variables $4, $5 y $6 contienen la primera, segunda y tercera nota, respectivamente, para cada linea. La suma de las tres variables divididas por 3 no es mas que el promedio de las notas. Si el patron se cumple (es decir, si el promedio de las notas es menor o igual a 4), el programa imprimra dos cosas: $0, es decir, la linea completa, y, ademas, el promedio calculado.\nVariables Pese a que AWK define ciertas variables, eso no nos limita. En nuestros programas, podemos modificar el valor de variables pre-definidas por AWK, o definir las nuestras propias.\nRecuerdan que dijimos que la solucion al problema 1 que planteamos antes no era optima? La razon es que imprime el numero de la linea en el archivo inicial, y luego la secuencia, pero no imprime la informacion de la secuencia en formato FASTA. En el formato FASTA, cada secuencia se anota (basicamente) de esta forma:\n\u0026gt;informacion de la secuencia AFFLWHHEIFHASQYCLGGGHEDRP (por supuesto, para las proteinas, las secuencias tienden a ser mas largas). Nuestro programa anterior en awk no escribia la primera linea, la que comienza en \u0026ldquo;\u0026gt;\u0026rdquo;. Escribamos un programa, algo mas complejo, que si lo hace:\nawk '/AAEGGEAAH/ {print ANTERIOR,\u0026quot;\\n\u0026quot;, $0}; {ANTERIOR=$0}' secuencias.fasta Es un poco dificil descifrar lo que hace este programa, porque involucra algo nuevo: Una variable definida por nosotros, que no estaba pre-definida por AWK. (ademas, este es el primer programa en el que definimos mas de una accion!)\nOK, veamos el programa. Tiene dos patrones. El primero es /AAEGGEAAH/ Como vimos, las barras \u0026ldquo;/\u0026rdquo; al rededor del texto indican que el patron se cumple si la linea actual contiene ese texto. En ese caso, el programa va a imprimir dos cosas: Primero, una variable llamada \u0026ldquo;ANTERIOR\u0026rdquo;, luego el texto \u0026ldquo;\\n\u0026rdquo; y finalmente, la linea actual ($0).\nEl texto \u0026ldquo;\\n\u0026rdquo; no es mas que el boton enter o cambio de linea.\nQue valor contiene la variable ANTERIOR?. Esa variable la definimos en la siguiente accion. La siguiente accion no tiene ningun patron, por lo que se ejecuta para todas las lineas. Lo unico que hace es definir la variable ANTERIOR como el texto de la linea actual.\nAca viene lo complicado. AWK ejecuta las acciones en el orden que nosotros se las damos. Ppor lo que si analiza un archivo que tiene este texto:\n\u0026gt;primera AAAAGRTYAAEGGEAAHHHEG En la primera linea, el patron /AAEGGEAAH/ no se cumple, por lo que AWK no realiza la accion {print ANTERIOR,\u0026quot;\\n\u0026rdquo;, $0}. Sin embargo, la siguiente accion no tiene patron asociado, por lo que se realiza siempre. Esto significa que desde ahora, la variable ANTERIOR tiene el siguiente valor: \u0026ldquo;\u0026gt;primera\u0026rdquo; (el contenido de la line actual).\nEn la segunda linea, el patron /AAEGGEAAH/ si se cumple, por lo que AWK realiza la accion:\n{print ANTERIOR,\u0026quot;\\n\u0026quot;, $0} Que valor tiene ANTERIOR? El ultimo que le asignamos, es decir \u0026ldquo;\u0026gt;primera\u0026rdquo;, por lo que awk imprime \u0026ldquo;\u0026gt;primera\u0026rdquo;, cambio de linea, y la linea actual. Es decir, AWK imprime:\n\u0026gt;primera AAAAGRTYAAEGGEAAHHHEG Una vez que esta accion se ejecuta, se vuelve a ejecutar la accion ANTERIOR=$0, por lo que el valor de ANTERIOR cambia, y pasa a ser \u0026ldquo;AAAAGRTYAAEGGEAAHHHEG\u0026rdquo;. Eso no importa, porque ya no vamos a imprimrla por ahora.\nEl tema de las variables es un poco complejo. Piensenlo un rato.\nPatrones especiales Como vimos, los proramas (simples) en AWK son conjuntos de pares patron-accion. En cada linea del archivo que estamos procesando, se analiza se el patron se cumple. Si es que esto es asi, la accion se ejecuta.\nExisten algunos patrones especiales. Vamos a ver dos:\nBEGIN BEGIN es un patron que se cumple al principio del archivo, antes de leer la primera linea. Es util para realizar acciones que queremos ejecutar solamente una vez, al comienzo. Por ejemplo, en el problema 2, en el que procesamos un archivo con notas para aislar solamente a los estudiantes con promedio menor o igual a 4. Podemos agregar el patron BEGIN al programa para ponerle un titulo al nuevo archivo que vamos a generar:\nawk 'BEGIN {print \u0026quot;Estudiantes que requieren apoyo especial\\n\u0026quot; } ($4+$5+$6)/3 \u0026lt;= 4.0 {print $0, ($4+$5+$6)/3}' notas.dat\nLa accion despues de BEGIN solamente se ejecutara una vez, al inicio.\nEND END es un patron similar a BEGIN, pero que se cumple al terminar el archivo, despues de leer la ultima linea.\nCambiando de separador, y otras variables pre-definidas. Que ocurre si los distintos campos de nuestro archivo de texto no estan separados por espacios? Por ejemplo, en nuestro problema 2, en lugar de espacios, podriams tener los nombres y notas separados por comas. En ese caso, cada linea del archivo seria:\nnomber,apellido,nota1,nota2,nota3\nNo hay problema! Solamente necesitamos cambiarla variable \u0026ldquo;FS\u0026rdquo; (field separator, separador de campos) que por defecto es \u0026quot; \u0026quot; por \u0026ldquo;,\u0026quot;. Esto lo podemos hacer al inicio del archivo, cuando se cumple el patron BEGIN. Un programa modificado para resolver elproblema 2 en un archivo separado por comas seria:\nawk 'BEGIN {FS=\u0026quot;,\u0026quot;};($4+$5+$6)/3 \u0026lt;= 4.0 {print $0, ($4+$5+$6)/3}' notas_coma.dat Otras variables pre-definidas interesantes:\n NF (number of fields, numero de campos) contiene el numero de campos en la linea actual NR (number of records, numero de registros) contiene el numero de lineas leidas hasta ahora  Funciones Una funcion es similar a una funcion matematica. Es una entidad (o sea, \u0026ldquo;algo\u0026rdquo;) a lo que le entregamos un valor, y nos devuelve otro. En el caso de los programas computacionales, una funcion, ademas de devolver un valor (o, en vez de devolver un valor) puede llevar a cabo una accion.\nEn AWK podemos definir nuestras propias funciones, o usar funciones pre-definidas. En este tutorial no voy a hablar sobre definir fuciones, y solamente voy a tratar una funcion pre-definida que me parece importante.\n gsub(\u0026ldquo;texto-a-buscar\u0026rdquo;,\u0026ldquo;texto-a-reemplazar\u0026rdquo;)  Esta funcion reemplaza todas las occurrencias del texto \u0026ldquo;texto-a-buscar\u0026rdquo; en $0 (la linea actual) por \u0026ldquo;texto-a-reemplazar\u0026rdquo;. Es basicamente el \u0026ldquo;buscar y reemplazar\u0026rdquo; de AWK. Como vamos a ver en la seccion siguiente, puede hacer bastante mas cosas que lo que normalmente se hace con \u0026ldquo;buscar y reemplazar\u0026rdquo;. Por ahora, veamos un ejemplo simple.\nImaginemos que, en nuestro ejemplo de las notas, en lugar de nuestra tarea anterior, queremos agregar un asterisco (*) al principio de las lineas que correspondan a estudiantes de apellido \u0026ldquo;Alvarez\u0026rdquo;. El codigo seria el siguiente:\nawk '{gsub(\u0026quot;Alvarez\u0026quot;,\u0026quot;*Alvarez\u0026quot;)}; {print}' notas.dat Proceso avanzado de texto. Tengo que confesarles algo. En el ejemplo:\n/AAEGGEAAH/ {print NR, $0} Les dije que el patron encerrado en \u0026ldquo;/\u0026rdquo; se cumplia si el texto encerrado entre las dos \u0026ldquo;/\u0026rdquo; estaba en la linea. esto no es exactaente cierto. La razon es que no necesariamente tenemos que poner el texto exacto que queremos ver si se encuentra en la linea! Podemos utilizar \u0026ldquo;patrones\u0026rdquo; que calzan con varios textos distintos. Por ejemplo:\n  Podemos buscar si la linea contine un texto que contenga \u0026ldquo;@\u0026rdquo; despues un texto cualquier, y terminara en .cl (ese patron se cumliria en todas las lineas que contuvieran direcciones de e-mail en servidores chilenos (como usach.cl, uchile.cl).\n  Podemos buscar si la linea contiene los caracteres \u0026ldquo;+56\u0026rdquo; y 9 digitos seguidos mas (este patron se cumpliria en lineas que contuvieran numeros telefonicos chilenos.\n  Podemos buscar si la linea contiene una secuencia de los siguientes aminoacidos: Dos Histidinas, una glicina o bien una alanina y tres cisteinas. Ese patron se cumpliria en lineas que contuvieran las secuencias \u0026ldquo;HHACCC\u0026rdquo; o \u0026ldquo;HHGCCC\u0026rdquo;.\n  Como se hace esto? Utilizando expresiones regulares. El uso basico de expresiones regulares (que es todo lo que uno generalmente necesita) es bastante sencillo, y muchas veces resulta util. Ademas de AWK, pueden usarse para buscar texto en algunos editores (Geany, un editor gratuito que funciona en Windows, Linux y MacOS, por ejemplo) y en varios otros lenguajes y herramientas.\nSi bien es sencillo, prefiero ponerlo en su propia pagina, para que esta no quede tan larga.\nContinuar leyendo sobre expresiones regulares Aplicaciones de Expresiones regulares en AWK Eliminando correos electronicos de un documento (o de varios documentos!) Imaginemos que tenemos un documento con informacion de, digamos, 500 personas cada uno, que debe subirse a internet. En general, para evitar el spam, es buena idea no poner direcciones de correo electronico en internet, salvo que sea estrictamente necesario. Necesario. Utilicemos la funcion gsub para eliminar las direcciones e correo de los distintos archivos. Una expresion regular que deberia funcionar es:\n.+@.+\\.[a-zA-Z]{1,3}/{print $0} Como toda buena expresion regular, se ve incomprensible, pero en realidad no lo es tanto. Si recuerdan, el punto simboliza cualquier caracter. El signo + que lo sigue, indica que este caracter (cualquier) debe repetirse al menos una vez (aunque pocos, hay nombre de usuario de email con solo una letra!). Despues de esta parte, que corresponde al nombre de usuario, debe venir un signo \u0026ldquo;@\u0026quot;. Finalmente, nuevamente cualquier caracter 1 o mas veces (notese que .+ significa \u0026ldquo;cualquier caracter\u0026rdquo; \u0026ldquo;lo anterior se repite 1 o mas veces\u0026rdquo;, es decir, no necesariamente es el mismo caracter el que tiene que repetirse varias veces). Finalmente, tenemos un punto (precedido de \u0026ldquo;\\\u0026rdquo; para indicar que nos referimos al caracter \u0026ldquo;.\u0026quot;, y no a \u0026ldquo;cualquier caracter\u0026rdquo;) seguido de entre una y tres letras (minusculas o mayusculas).\nEsta expresion regular es aceptable para detectar direcciones de email, pero tiene algunos problemas.\n Acepta cualquier combinacion de caracteres como nombre de usuario. Que yo sepa, los nombres de usuario solo pueden contener letras, numeros, puntos y guiones (\u0026quot;-\u0026rdquo; y \u0026ldquo;_\u0026quot;). Lo mismo para el servidor (lo que viene detras de la arroba).  Usemos la expresion regular junto con gsub() para buscar y reemplazar correos en un archivo:\nawk '{gsub(\u0026quot;.+@.+\\.[a-zA-Z]{1,3}\u0026quot;,\u0026quot;RETIRADO\u0026quot;)};{print $0}' archivo1.txt archivo2.txt archivo3.txt Ese programa reemplaza direcciones de correos por la palabra \u0026ldquo;RETIRADO\u0026rdquo; en todas las lineas (debido a las limitaciones de la regex que comentamos, es posible que reemplace texto que no corresponde realmente a una direccion de correo).\nRecursos adicionales Lamentablemente, estos libros estan (o, al menos, yo los encontre) solamente en ingles.\n El principal libro sobre AWK, por sus creadores Otro buen libro (o, eso entiendo) y gratuito Otro libro gratuito (ignoro que tan bueno es)  "});index.add({'id':5,'href':'/docencia/docs/linux/','title':"Linux",'content':"Linux Linux es un sistema operativo libre y gratuito, flexible y con una serie de ventajas sobre otros sistemas operativos. Cualquier estudiante de Quimica/Bioquimica computacional y/o de Bioinformatica requiere un conocimiento de este sistema operativo, al menos a nivel de usuario.\nLinux a nivel de usuario  Copyright (c) Raul Mera A.\nEl autor dedica su esfuerzo a la larga vida del Ven. Khenpo Phuntzok Tenzin Rinpoche\nTodo el contenido de esta wiki está bajo una Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional\n"});index.add({'id':6,'href':'/docencia/docs/linux/guia_basica/','title':"Linux a nivel de usuario",'content':"Linux a nivel de usuario Esta es una guia para el uso basico a intermedio de sistemas basados en Linux, con algunos detalles de administracion. Existe desde hace varios anios como una guia utilizada al interior de mi grupo de investigacion, pero, considerando la necesidad de contar con el mayor numero de recursos de aprendizaje disponibles, ha sido formateada en Markdown y puesta a disponibilidad general en esta wiki.\nContenidos  Historia y caracteristicas basicas de sistemas UNIX Uso practico de Linux  Anexo Comandos de UNIX/Linux de uso frecuente Ordenados por nivel\n Basico intermedios   Copyright (c) Raul Mera A.\nEl autor dedica su esfuerzo a la larga vida del Ven. Khenpo Phuntzok Tenzin Rinpoche\nTodo el contenido de esta wiki está bajo una Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional\n"});index.add({'id':7,'href':'/docencia/docs/linux/guia_basica/uso_practico/','title':"Uso Practico",'content':"El arbol de directorios (carpetas)  El árbol de directorios (carpetas, si se quiere) UNIX es relativamente estándar, uno puede esperar que a grandes rasgos se mantenga no solo en las distintas distribuciones de Linux, si no también en otros UNIX. El directorio raiz se llama “/”, todos los otros directorios son sub-directorios de este. Si un directorio A es subdirectorio de un directorio B se dice que B es el padre de A. En UNIX, el simbolo / se usa para el directorio raiz y ademas para separar nombres de directorios, por ejemplo: /home/bin, el directorio bin es un subdirectorio de home, que es un subdirectorio del Raiz (“/”).\nAlgunos directorios importantes.   /home Aca estan los directorios personales o de trabajo de los usuarios\n  /etc Donde se encuentran los archivos de configuración\n  /usr contiene archivos que no son del sistema mismo sino para ser utilizados por los usuarios.\n  /dev contiene archivos que representan al hardware presente en el computador\n  /proc contiene archivos relacionados con el kernel: El kernel escribe información que podemos consultar en archivos de este directorio, y, en algunos casos, lee información que podemos escribir ahi.\n  Usuarios y permisos UNIX es un sistema multiusuario, lo que significa que varias personas pueden conectarse al computador a la vez, y cada uno tiene su propio directorio y tal vez programas que otros usuarios no pueden leer o modificar. Cada archivo en UNIX tiene un propietario y “permisos” de lectura, escritura y ejecución. Cada usuario decide quien puede leer, escribir en (incluyendo borrar) o ejecutar sus archivos. Este sistema de usuarios y permisos es critico en la prevencion de ataques e infecciones por virus informaticos\nUna excepción es el usuario “root” (Administrador del sistema) que siempre puede leer, escribir en o ejecutar cualquier archivo. Root puede cambiar el permiso e incluso el propietario de cualquier archivo.\nEntorno grafico El entorno grafico de Linux (y la mayoría de los sistemas UNIX) está basado en lo que se conoce como “X Window” (hoy en dia, Linux ha compenzado a reemplazar X Window por otros sistemas). Sobre esas librerías funcionan gestores de ventanas y entornos de escritorio que nos proporcionan experiencias de usuario similares a las que encontramos en Windows o MacOS (incidentalmente, MacOS es un sistema UNIX derivado de FreeBSD, aunque usa su propio sistema para entorno gráfico en lugar de X). Algunos entornos disponibles en Linux son Gnome, KDE, XFCE y LXDE.\nUso de la interfaz de linea de comandos (CLI) (tambien llamda terminal, o, shell) Uso basico Que es la iterfaz de linea de comandos (CLI). La interfaz de linea de comandos es una forma no-grafica de comunicarse con el sistema operativo. Esto significa que en la CLI escribimos comandos que llevan a cabo las funciones que necesitamos.\nShells (bash, csh, zsh, fish, ksh) La shell es el programa que recibe comandos del usuario y los transmite al sistema (osea, para nuestros propositos shell es lo mismo que CLI). Hay varios tipos de shells con diferencias menores entre ellas. Hay shells antiguas/tradicionales como bourne shell, (sh), csh, ksh, la semi-moderna GNU bash (bourne again shell) y las más nuevas zsh y fish. En linux, bash es lejos la más usada y la que discutimos en este curso.\nComandos, programas, argumentos. Entrada, salida y error estandar. Cuando se ingresa un comando en la shell, lo que realmente se hace es pedirle a la shell que ejecute el programa cuyo nombre es el comando ingresado (recordar que en unix cada programa hace un trabajo, y lo hace bien, la shell no hace nada más que comunicar al usuario con el SO). Los comandos/programas que se ingresan muchas veces aceptan o requieren argumentos y/u opciones. Por ejemplo, el comando mkdir crea un directorio, requiere como argumento el nombre del directorio a crear. El programa/comando ls muestra los contenidos de un directorio, acepta argumentos que determinan el formato en los que se muestran.\nLos programas comúnmente muestran información, y, a veces, requieren información. Por defecto, cuando un programa “escribe” información, lo hace en la llamada “salida estándar” (standard output, stdout) que normalmente es el monitor. Adicionalmente, los errores que un programa imprima se imprimirán en el “estándar de errores” (stderr), normalmente también el monitor. Cuando un programa requiere información (input) la toma comúnmente de la entrada estandar, (standard input, stdin) que suele corresponder al teclado. Es posible modificar de donde lee y a donde escribe información un programa, como se verá más adelante.\nAqui una lista de comandos basicos\nUso intermedio Redirigiendo input y output. El comportamiento normal de un programa de UNIX es escribir en stdout. Sin embargo es posible redirigir ese flujo de información a un archivo, usando los operadores \u0026gt; y \u0026gt;\u0026gt;. Por ejemplo, el comando\n ls \u0026gt; archivo.txt  redirige la salida de ls al archivo archivo.txt. Es decir, en lugar de mostrar el contenido del directorio actual en pantalla, escribirá estos contenidos al archivo. Si se usa el operador \u0026gt;, se crea un nuevo archivo y cualquier archivo anterior con el mismo nombre se borra. Si se usa el operador \u0026raquo;, y existe un archivo anterior con el mismo nombre, el flujo se agrega al final de lo que ya habia en el archivo (de no existir un archivo con ese nombre se crea un archivo nuevo).\nSi se utiliza\n ls 2\u0026gt; archivo.txt  la salida estandar no sera redirigida, pero el error estandar se redirigira a archivo.txt. Considere un comando que espera imprima un gran numero de errores que Ud. puede ignorar, pero que dificultan la leida de la salida del programa. En ese caso es posible escribir: “\n programa 2\u0026gt; /dev/null  con lo que el error del programa sera redirigido al archivo /dev/null. /dev/null es un archivo falso que ignora todo lo que se escribe en el, por lo que solamente la salida del programa aparecera en pantalla, mientras que los errores seran ignorados.\nEl operador \u0026lt; es equivalente, pero redirige la entrada estándar. Si un programa requiere información (aparte de las opciones y argumentos) de la entrada estandar, uno puede entregar el contenido de un archivo en lugar de escribir esa información, de la manera siguiente:\n comando \u0026lt; archivo.txt  Pipelines o tuberias Las pipelines o tuberías son otra forma de redirigir input/output. En este caso, lo que hacemos es comunicar dos programas, de forma que la salida de uno sea la entrada del otro. Por ejemplo, el comando ls muestra el contenido de un directorio. Que ocurre si el directorio contiene demasiados archivos como para que quepan en la pantalla? Una opción es redirigir la salida de ls a un programa que nos permita ver el texto de manera más simple, como el comando less. Esto se hace con una tubería que “conecta” ambos programas. El simbolo de tubería o pipeline es “|”\n ls | less  como no le estamos entregando argumentos a less, mostrara lo que venga por la entrada estándar. Mediante la tubería, reemplazamos la entrada estandar que entregamos a less por la salida de ls.\n ls | wc  Nos entregará el número de palabras en la salida de ls, que (si cada directorio tiene una palabra) equivaldrá al número de directorios.\n cat archivo1 archivo2 archivo3 | wc  contará las palabras totales en los tres archivos dados a cat.\nEsta es una manera común de combinar programas en UNIX (recordar que cada programa debería hacer una sola cosa cosa, y hacerla bien bien, por lo que combinarlos es importante) Por esta razón, todo programa escrito para UNIX que reciba información debería poder recibir input desde la entrada estándar si es que no recibe una entrada como argumento, y debería escribir a la salida estándar.\nEjecutando programas en el \u0026ldquo;fondo\u0026rdquo; (background) Un simbolo de la shell que puede ser útil es “\u0026amp;” que sirve para ejecutar un programa en el “fondo” (background). Normalmente, la shell se congela mientras ejecutamos un programa, y no podemos escribir otro comando hasta que la ejecución termina. Esto puede evitarse usando \u0026amp;, lo que puede ser útil para programas que demoran en ejecutarse, como un cálculo de mecanica cuántica.\nVariables de la shell (incluye PATH, HOME)\tel archivo .bashrc Como hemos visto, la shell proporciona varias herramientas para facilitar nuestro trabajo (tuberias, redireccion). Otra herramienta importante son las variables de la shell. Una variable es un espacio en la memoria ligado a un nombre (el nombre de la variable) que contiene un valor. Por convencion, los nombres de variables de shell se escriben con mayusculas. Por ejemplo:\n NUMERO=2  crea una variable llamada NUMERO que contiene el valor 2. Si escribimos el signo dolar antes del nombre de una variable, la shell sustituira el nombre (y el signo dolar) por el valor de la variable.\nEn el siguiente ejemplo:\nexport FILE=archivo.txt less $FILE El comando less nos mostrara el contenido de archivo.txt. El comando “export” no es necesario para definir una variable, uno podria simplemente hacer\n FILE= archivo.txt  Sin embargo, export permite que cualquier programa lanzado desde la shell tenga acceso a la variable. Esto es muchas veces necesario y es aconsejable siempre usar “export” salvo que se quiera expresamente lograr el efecto contrario.\nHay varias variables pre-definidas por la shell, varias de ellas usadas internamente por ella. La mas importante es PATH. PATH contiene un conjunto de directorios, separados por “:” donde la shell busca un programa con el nombre del comando que el usuario introduzca para ejecutarlo. Cuando ejecutamos ls, la shell busca en los directorios de la variable PATH un programa con ese nombre, y lo ejecuta (los programas basicos del sistema como ls estan en el directorio /bin).\nPodemos ver el contenido de la variable PATH haciendo:\necho $PATH Normalmente este comando imprimira algo como:\n/bin:/usr/bin:/usr/local/bin:/opt/bin Si queremos ejecutar un programa que no esta en el PATH, tenemos que entregar su ubicación:\n /directorio/subdirectorio/programa  O si esta en nuestro directorio actual:\n ./programa  Es posible modificar las variables de la shell editando el archivo .bashrc que se encuentra en nuestro directorio home (normalmente /home/nombredeusuario) Para agregar un directorio nuevo a PATH (por ejemplo, /home/rmera/bin) escribiriamos en .bashrc lo siguiente:\nexport PATH=$PATH:/home/rmera/bin\nUna vez escrito esto y guardado (salvado, saved) el archivo, los cambios no se observaran hasta que iniciemos una nueva shell (puesto que la shell lee .bashrc al iniciarse). Una manera de hacer que la shell lea (ejectute) un archivo es utilizando:\n source archivo  por lo que ingresando el comando\nsource ~/.bashrc se actualizará la variable PATH.\nOtra variable predefinida de la shell es HOME, que contiene el directorio home del usuario.\nAqui una lista de comandos intermedios\nEl editor de texto Nano Nano es un editor de texto simple para UNIX. Esta presente en casi todas las instalaciones, por lo que es bueno tener una idea minima de como usarlo (podria ser el unico editor disponible).\nPara comenzar a editar un archivo el comando es:\n nano archivo  Una vez en el editor, es posible cerrar el editor, sin guardar los cambios realizados al archivo, presionando las teclas “control” (ctlr) y “x” a la vez (ctrl+x) (el editor pedira confirmar si se desean guardar los cambios). Para guardar los cambios realizados a un archivo (sin salir del editor) se usa la combinacion ctrl+o.\nEl navegador web de texto lynx. Hay varios motivos por los que podriamos querer navegar la web desde la CLI (en lugar de usar un navegador grafico como Mozilla Firefox o Google Chrome). Algunos serian que el entorno grafico no estuviera disponible en el computador, o que no quisieramos iniciar una sesion grafica solo para una busqueda breve.\nlynx permite navegar por internet desde la CLI. Desde luego, no es posible ver imagenes ni el formato del texto, pero en varios casos el texto plano es suficiente. Para iniciarlo:\n lynx http://www.direcciondeinternet.com  Puede manejarse la navegacion con las flechas hacia arriba y abajo (que saltaran de link a link). Con la flecha hacia la derecha se sigue el link donde el cursor esta actualmente.\nEl gestor de archivos Midnight Commander Midnight Commander, o MC, es un gestor de archivos de dos paneles, similar al antiguo Norton Commander para MS-DOS o a varios programas equivalentes. MC es muy versatil, y puede utilizarse remotamente (osea, via ssh). Aca vemos las funciones basicas. Mi recomendacion es que MC siempre este instalado en todos los computadores con Linux, puesto que hace que el uso de la CLI/shell sea mucho mas simple y comodo.\nAl ingresar a MC (con el comando “mc”) por primera vez, lo primero es presionar F9 y utilizar las flechas hacia el lado para seleccionar la opcion “options”. Con la flecha hacia abajo ir a la tercera opcion “Panel options”, presionar “enter”, usar las flechas hacia abajo para llegar a la opcion “Lynx-like motion” y presionar la barra espaciadora para que la opcion quede marcada. Seguir presionando la flecha hacia abajo hasta llegar a “Ok”, y presionar enter. Esta configuracion facilita el uso del programa.\nEl uso de MC es simple. El programa presenta dos paneles, cada uno muestra el contenido de un directorio (pueden mostrar cada uno un directorio distinto, o ambos el mismo directorio) Para cambiar el cursor de un panel a otro presione la tecla Tab. Para moverse por el panel use las flechas hacia arriba y abajo. Cuando el cursor este en un directorio, puede presionar la flecha a la derecha para entrar en el. Con la flecha a la izquierda se va al directorio padre del actual.\nAlgunas teclas y combinaciones utiles para MC   F5 Copia el archivo (o directorio) donde esta el cursor al directorio del otro panel, con F6 el archivo se mueve al directorio del otro panel. Con F8 se borra el archivo o directorio donde esta el cursor. Pueden copiarse/moverse/borrarse varios archivos a la vez si los selecciona previamente presionando “insert” cuando el cursor esta sobre el archivo.\n  F3 Muestra el contenido de le archivo donde esta el curso.\n  F4 se usa el editor incluido en MC para editar el archivo donde esta el cursor.\n  F9 Accede a las opciones.\n  F10 se sale de MC (quit).\n  Alt+i (presionar la tecla Alt y, sin soltarla, presionar \u0026ldquo;i\u0026rdquo;) se cambia el otro panel al mismo directorio del panel donde esta el cursor.\n  Ctrl+o Cambia a una shell normal para ingresar comandos. Utilizando la misma combinacion nuevamente, vuelve al modo normal de MC.\n  Alt+enter. Ecribe automaticamente en la shell el nombre del archivo o directorio donde esta el cursor (util para ejecutar un comando en un archivo de nombre largo).\n  Las opciones accesibles con F9 permiten flitrar archivos (por ejemplo mostrar solo archivos que terminen en .pdf) conectarse a otro computador con uno de los dos paneles, etc. Archivos comprimidos como tgz, tbz o zip pueden verse ingresando en ellos como si fueran un directorio. Posteriormente uno puede copiar los contenidos al directorio del otro panel.\nLamentablemente, muchos adminisitradores de sistemas no instalan MC en sus maquinas, por lo que puede o no estar disponible en un computador dado. Siempre es posible intentar convencer al administrador de que lo instale :-)\n Copyright (c) Raul Mera A.\nTodo el contenido de esta wiki está bajo una Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional\n"});index.add({'id':8,'href':'/docencia/docs/estadistica/bayes/','title':"Bayes",'content':"El Teorema de Bayes, con una aplicacion a la crisis de COVID19 En varios casos nos enfrentamos a problemas del tipo \u0026ldquo;Cual es la probabilidad de que X sea cierto si sabemos que Y es cierto?\u0026rdquo;\nLa probabilidad de la pregunta se conoce como \u0026ldquo;Probabilidad Condicional\u0026rdquo;, y se denota P(X|Y).\nTomemos los casos de COVID19 en Chile como ejemplo. Sabemos que es muy dificil realizar tests a todas las personas infectadas, por lo que el numero de casos confirmados es, casi seguro, menor que el numero de contagiados reales. Sin embargo, si conocemos el numero de personas hospitalizadas por la enfermedad (pacientes serios o criticos). Podemos usar ese numero para estimar el numero de enfermos totales.\nEn este caso, queremos conocer la probabilidad de tener E personas enfermas si sabemos que las personas hospitalizadas son un numero conocido H. Queremos determinar P(E|H)\nQue es lo que sabemos? Sabemos algo importante, el porcentaje de personas enfermas que requieren hospitalizacion Al menos, podemos obtener un estimado razonable de este numero mirando el caso de un pais que tenga muy alta cobertura de tests, digamos, Alemania. Tomando los numeros que aparecen en aqui podemos concluir de Alemania que el porcentaje de hospitalizacion es cercano al 3.6% de los casos totales. Es decir conocemos la probabilidad de tener H hospitalizados si tenemos E personas enfermas totales. Conocemos P(H|E).\nComo podemos determinar P(E|H) si conocemos P(H|E). Ahi es donde entra el teorema de Bayes! Veamos la formula. Para nuestro problema, el teorema seria:\n \\[P(E|H) = \\frac{P(H|E)P(E)}{P(H)}\\] Notese que aparecen dos funciones que no habiamos visto!\n  P(E) es la probabilidad a priori de que E personas esten enfermas. Como no tenemos ningun dato, vamos a dejarla como \u0026ldquo;uniforme\u0026rdquo;. Es decir, la misma probabilidad para todo E.\n  P(H) es la probabilidad de que tengamos H pacientes hospitalizados, independiente del numero de enfermos. En otras palabras, es P(H|E) integrada en E desde 0 hasta infinito:\n  \\[P(H)=\\int_0^{\\infty}P(H|E)P(E)dE\\] Entonces, los valores que necesitamos son la integral de P(H|E) de 0 a infinito, para el denominador, y el valor de P(H|E) para un H dado. Aca tenemos un problema. Sabemos que la probabilidad de que una persona enferma requiera hospitalizacion es 0.36%, pero cual es la probabilidad de que H personas requieran hospitalizacion si hay E enfermas? Esto es similar a la probabilidad de sacar X \u0026ldquo;caras\u0026rdquo; al lanzar una moneda Y veces, si la probabilidad de sacar cara en cada lanzamiento es de P%. Conociendo P, la respuesta la da la llamada distribucion binomial. Entonces, en nuestro caso, P(H|E) es la distribucion binomial con P=0.36%. Por si acaso tuvieramos una pequena incerteza en el numero de hospitalizados (puesto que cambia con rapidez) en vez de tomar el valor de P(H|E) para un unto H, voy a tomar la integral de la funcion entre dos puntos H1 y H2.\nYa casi tenemos el resultado!\nAhora mismo tenemos todo para obtener la probabilidad de tener E personas enfermas dado que hay H hospitalizadas. El problema es que esa es la probabilidad de tener exactamente E personas enfermas, que nunca va a ser un numero muy grande. Lo que realmente queremos es la probabilidad de tener E personas enfermas o menos. Es decir, la sumatoria de todo lo que hicimos, entre 0 y E. Lo que tenemos que calcular seria:\n\\[\\sum_0^E\\frac{\\int_{H_1}^{H_2}P(H|E)P(E)dH}{\\int_0^{\\infty}P(H|E)P(E)dE}\\] Puesto que P(E) es uniforme (basicamente, 1) podemos sacarla y obtener:\n\\[\\sum_0^E\\frac{\\int_{H_1}^{H_2}P(H|E)dH}{\\int_0^{\\infty}P(H|E)dE}\\] No se preocupen, no tienen que hacer el calculo ustedes mismos. Aca puse un programita que, dados los numeros, hace las matematicas por Uds:\nIr al programa de estimado Bayesiano\nFelices calculos!\nRecursos  https://www.youtube.com/watch?v=HZGCoVF3YvM https://www.youtube.com/watch?v=R13BD8qKeTg https://www.youtube.com/watch?v=9TDjifpGj-k   Pd. El estimado basado en este metodo es mas o menos crudo. Para el porcentaje de hospitalizacion, simplemente tome la cantidad de hospitalizados actuales y la cantidad de casos activos actuales en Alemania. Como todo el material de esta wiki, el objetivo es ensenar, no entregar predicciones.\n"});index.add({'id':9,'href':'/docencia/docs/programacion/regex/','title':"Expresiones Regulares",'content':"Expresiones regulares Lo que aparece en este capitulo es valido no solamente para AWK, sino para varias otras herramientas (como el editor Geany, que corre en Windows, MacOS y Linux, asi como para las herramientas de UNIX [Linux y MacOS] grep y sed) y varios lenguajes de programacion, incluyendo Perl, Python, Go (probablemente casi cualquier otro).\nEn este capitulo asumo que acaban de leer el capitulo anterior o que tienen una idea de lo que son las expresiones regulares (o, regex).\nEn pocas palabras, son \u0026ldquo;patrones\u0026rdquo; que calzan con varios textos distintos.\nPodriamos decir, entonces, que una expresion regular es una expresion que \u0026ldquo;calza\u0026rdquo; en una serie de textos (cadenas de caracteres\u0026rdquo; objetivo.\nComo se logra esto? Con un conjunto de caracteres especiales que representan distintos tipos de caracter (letra, digito o simbolo) y otros que representan las veces que esos caracteres deberian ocurrir en la cadena objetivo para que ocurra el \u0026ldquo;calce\u0026rdquo; (match).\nVeamos uno de los ejemplos del capitulo anterior.\nTenemos un archivo de texto, y queremos detectar las lineas que contienen un numero de telefono chileno. Es decir, queremos una expresion regular que calce solamente con numeros de telefono chilenos. Que define a un numero telefonico de Chile? Que comience con los caracteres \u0026ldquo;+56\u0026rdquo; y contenga 9 digitos mas.\nVeamos una expresion regular que calza con ese patron:\n\\+56[0-9]{9} Admito que se ve raro, pero lo que dice es lo siguiente: Los primeros caracteres son \u0026ldquo;+56\u0026rdquo;, luego sigue cualquier caracter entre 0 y 9, y eso mismo (cualquier caracter entre 0 y 9) se repite 9 veces.\nVamos por parte.\n  El \u0026ldquo;\\\u0026rdquo; antes del signo \u0026ldquo;+\u0026rdquo; es necesario porque el signo + tiene un significado propio en las expresiones regulares (que vamos a ver mas abajo). Debido a esto, tenemos que agregar el \u0026ldquo;\\\u0026rdquo; adelante para indicar que nos referimos al simbolo \u0026ldquo;+\u0026rdquo; textual, no al significado que tiene ese simbolo en el lenguaje de expersiones regulares. Esto es necesario si queremos referirnos a cualquier simbolo que tenga un significado en las regex (como,\u0026quot;}\u0026quot;,\u0026quot;)\u0026quot;,\u0026quot;*\u0026rdquo; etc).\n  El [0-9] es un patron que calza con cualquier caracter entre los dos que aparecen. Asi, [a-z] es cualquier letra minuscula, [A-Z] es cualquier letra mayuscula. En los corchetes uno puede dar un rango, como 0-9, o dar especificamente los caracteres que se aceptan. Por ejemplo, [01] calza solamente con los caracteres 0 y 1. [0-9] es equivalente a [0123456789].\n Cuando al principio se le agrega \u0026ldquo;^\u0026rdquo; dentro del corchete, el significado pasa a ser \u0026ldquo;cualquier cosa menos lo que esta entre los corchetes\u0026rdquo;. Por ejemplo, [^0-9] calza con cualquier no-digito. [^A-Z] calza con cualquier cosa que no sea una letra mayuscula y [^234] calza con cualquier caracter menos 2, 3 o 4. (Nota: \u0026ldquo;^\u0026rdquo; tiene un significado diferente cuando se usa fuera de los corchetes!. Ese significado se discute mas abajo). Es posible combinar rangos, como [A-Z] con caracteres explicitos, o dos o mas rangos. [A-Z12] calza con cualquier letra mayuscula, el numero 1 y el numero 2.[a-zA-Z] calza con cualquier letra, minuscula o mayuscula.    El {9} indica que el patron anterior (en este caso, [0-9]) debe aparecer exactamente 9 veces. Uno puede usar el cuantificador \u0026ldquo;{}\u0026rdquo; de varias formas: {3,5} significa que el patron anterior debe aparecer entre 3 y 5 veces. {2,} significa que el patron anterior debe aparecer dos veces o mas y {,6} que debe aparecer entre 0 y 6 veces. Por supuesto, podemos reemplazar los numeros que use en los ejemplos por otros cualesquiera.\n  Localizadores o \u0026ldquo;anclas\u0026rdquo;  ^ Indica que la expresion regular que viene a continuacion debe ocurrir al principio del texto objetivo. Por ejemplo, la expresion:  ^\\+56[0-9]{9} Solo calzara con las lineas que comiencen con un numero telefonico chileno\n $ Indica que la expresion regular que lo precede debe ocurrir al final del texto objetivo. La expresion:  \\+56[0-9]{9}$ Solo calzara con las lineas que terminen con un numero de telefono chileno.\nY Listo Eso es lo basico que uno necesita para el uso comun de expresiones regulares. Seguramente algunos gurues de las regex van a sufrir un infarto por lo que acabo de escribir, pero es cierto en mi experiencia. De hecho, yo mismo no me se algunas de estas cosas de memoria, tipicamente las busco cuando las necesito (por ejemplo, desde ahora en adelante las voy a buscar aqui mismo!)\nLo que viene es no esencial, pero es comodo, y es bueno tenerlo como referencia. Dale una mirada breve y puedes seguir con el uso de regexes en AWK\nCuantificadores abreviados Vimos ya el principal cuantificador {}. En realidad es todo lo que necesitamos, pero a veces conviene usar cuantificadores abreviados:\n + Indica que el patron anterior debe ocurrir una o mas veces. Es equivalente a {1,} * Indica que el patron anterior debe ocurrir cero o mas veces.  Algunos \u0026ldquo;atajos\u0026rdquo;.  \\d Calza con cualquier digito. Equivale a [0-9] \\D Calza con cualquier no digito \\s Calza con cualquier cantidad de espacios en blanco, tabuladores o similares. . Cualquier simbolo salvo el salto de linea  Un \u0026ldquo;torpedo\u0026rdquo; para expresiones regulares. Una vez que entienden como funcionan las regex, no necesitan memorizar nada, o casi nada. Bajen este torpedo (en ingles, pero las explicaciones son muy breves) y peguenlo en la pared detras del computador :-)\n"});index.add({'id':10,'href':'/docencia/docs/linux/guia_basica/comandos/','title':"Comandos",'content':"Convenciones El formato que usamos en esta guia es:\ncomando [-opcion1 -opcion2] argumento1 argumento2 \u0026hellip;\nEn general las opciones pueden escribirse también: comando -opcion1opcion2. Los corchetes se usan para delimitar opciones, pero no deben incluirse al escribir el comando. El texto en cursiva representa algo que debe reemplazarse por texto según el requerimiento del usuario. A veces se usan puntos suspensivos para indicar que es posible agregar más argumentos del mismo tipo. Solamente se entregan las opciones comunmente usadas (segun el subjetivo criterio del autor).\nEn varios casos, se puede utilizar “comodines” en argumentos para comandos. Estos comodines representan varios caracteres a la vez y permiten ejecutar el comando en varios argumentos a la vez. Los principales comodines son “*”: cualquier caracter, cualquier numero de veces y “?”: Cualquier carácter, una vez.\nComandos basicos man comando Muestra una ayuda (manual) para el comando especificado. Normalmente la guía mostrada es bastante extensa e incluye todas las opciones del comando. Para salir de la ayuda basta presionar la tecla “q”.\nhalt Apaga el computador (solo el administrador de sistema, o root, puede usar este comando)\nls [-l -a -t] Lista los contenidos de un directorio. -l entrega un formato largo, con información adicional, -a muestra también los archivos ocultos (cualquier archivo cuyo nombre comience con un punto) y -t ordena los archivos en orden de modificación (los más nuevos primero)\ncd directorio Cambia nuestro directorio actual al directorio especificado. El nombre “.” equivale al directorio actual (el comando no hace nada), el nombre “..” equivale al directorio padre del actual, el nombre “~” es nuestro directorio “home” o de trabajo. Si no se entrega argumento, cd nos lleva a nuestro directorio home. Ejemplos: cd ~/proyectos/porfirinas nos lleva al directorio porfirinas que es un subdirectorio de proyectos, que es un subdirectorio de nuestro directorio home. cd ../calculos nos lleva al directorio calculos que es un subdirectorio del directorio padre de nuestro directorio actual.\nmkdir nombredirectorio Crea un directorio con el nombre especificado. Uno puede entregar un camino (path) absoluto, partiendo desde la raíz (ej. mkdir /home/rmera/proyectos) o simplemente un nombre (ej. mkdir proyectos). En el último caso, mkdir crea un subdirectorio en el directorio actual.\nrm [-R -f] archivo Borra un archivo. Si se intenta borrar un directorio, no lo hace e imprime un error. Si se usa la opción “-R” (borrado recursivo) se puede borrar un directorio. Todo lo que contenga el directorio, se borrara tambien. En ocasiones, rm pide confirmar que se desea borrar un archivo, la opción “-f” (forzar) hace que todos los archivos se borren sin pedir confirmación.\ncp [-R] archivo1 archivo2 Hace una copia de archivo1 llamada archivo2. Si archivo1 es un directorio se debe usar la opción -R, que copiara todos los contenidos de ese directorio a archivo2.\nmv archivo1 archivo2 Mueve archivo1 a archivo2. Puede usarse para mover un archivo a un nuevo directorio (ej mv file ../file) o simplemente para renombrar un archivo.\nln [-s] archivo1 archivo2 Crea un “link” del archivo1 con el nombre de archivo2. archivo2 podra usarse como si fuera archivo1, y modificar uno de ellos afectará al otro (sin embargo si archivo2 se borra, archivo1 no se borrara. Si arechivo1 se borra, archivo2 pasa a ser un “link roto”, que no lleva a ninguna parte). Los links son equivalentes a los “accesos directos” de windows. Por razones que van más allá del propósito de este curso, el comando ln siempre debe usarse con la opción “-s”.\ncat archivo1 archivo2 \u0026hellip; Imprime el contenido de el o los archivos que se entreguen como argumentos en la salida estándar. El nombre del comando viene de “concatenar” que e slo que hace si se le entregan varios nombres de archivos.\ntail [-f] archivo Muestra las últimas líneas de un archivo. Si el archivo está siendo escrito y quiere verse como cambia en tiempo real puede usarse la opción f (follow). Si se usa esta opcion, se requerirá ctrl+C para salir del programa.\nless archivo Es una especie de visor de texto, que no permite editar. Si no se le entrega un argumento, mostrará lo que se le entregue en la entrada estandar.\npwd Imprime el nombre del directorio actual en la salida estándar.\nwc archivo Imprime el número de palabras en un archivo (entre otros datos). Si no se le entregar un archivo, imprimirá el número de palabras de lo que se le entregue en la entrada estándar.\necho texto Imprime en la salida estándar lo que se le entregue como argumento. La utilidad de este programa queda clara mas adelante.\ntouch archivo Crea un archivo vacío o actualiza la fecha de última modificación de un archivo, sin realmente modificarlo.\nwget direcciondeinternet/archivo Baja el archivo dado de la direccion de internet (esto es, una direccion IP o el nombre de un servidor). Solo funciona si el servidor es de acceso publico (osea, no requiere autenticación).\nComandos intermedios su usuario Transforma al usuario actual en usuario. Si no se entrega ningun usuario, transformara al usuario en administrador de sistemas, o “root”. Obviamente, requiere que se entregue la contrasena del usuario a transformarse en.\ndu [-sh] archivo Imprime el uso de disco de los archivos que se le entreguen. La opcion “-h” debe utilizarse siempre, ya que hace que los resultados sean entendibles por humanos (osea, GB, MB, kB, etc). Si el archivo es un directorio, du mostrara el uso de disco por cada archivo, salvo que se entregue la opcion -s (summary), en cuyo caso se entregara solo el total.\ndf [-h] Muestra el espacio libre y usado en los medios de almacenamiento (discos) disponibles, la opcion -h tiene el mismo significado que en el comando du\nfree [-h] Muestra la memoria (i.e. RAM) total, usada y disponible, la opcion -h tiene la misma funcion que en los dos comandos anteriores.\nchmod [-R] permiso archivo Cambia los permisos del archivo. Los permisos son lectura (r ), escritura (w) y ejecucion (x) y se dan y quitan con “+” y “-” respectivamente. Por ejemplo:\nchmod +r file.txt Autorizaria a otros a leer el archivo file.txt. Chmod puede usarse para dar permisos solo a algunos usuarios, pero ese uso va mas alla de los propositos de esta guia. Si estamos cambiando los permisos de un directorio podemos usar la opcion -R para que el cambio afecte a todo el contenido de ese directorio\nchown [-R] usuario.usuario archivo Cambia al propietario de un archivo al usuario de preferencia. La razon por la que el number de usuario se entrega dos veces separada por un punto es que en UNIX no hay solo usuarios, si no que estos pueden juntarse en grupos. chown requiere que se entregue un grupo del usuario (cada usuario puede pertenecer a varios grupos). Cada usuario pertenece por lo menos a un grupo con su nombre. La opcion -R cumple la misma funcion que en chmod.\nsed [-i] ‘s/patron1/patron2/g’ archivo Busca patron1 en archivo y lo reemplaza por patron2. Los patrones pueden ser expresiones regulares. Si se utiliza la opcion g al final (como aparece al principio de este parrafo) se reemplazan todas las ocurrencias de patron1, en caso contrario, se reemplaza solo la primera ocurrencia de cada linea. La opcion “-i” (“in place”) hace que sed modifique el mismo archivo de entrada. Si no se entrega, sed imprime la version modificada del archivo en la salida estandar.\ngrep [-i -v] “patron” archivo Busca en archivo todas las lineas donde ocurra el patron dado, y las escribe en la salida estandar. Si no se entrega un archivo, grep analizara lo que llegue por la entrada estandar, por lo que es facil acoplarlo con tuberias a la salida de otro programa. “patron” es una expresion regular. La opción -v imprime las lineas que NO contengan el patron.\nLa opcion \u0026ldquo;-i\u0026rdquo; ignora las mayuculas. El ejemplo:\ngrep -i “FINAL” mycalculation.out imprimira las lineas de mycalculation.out que contengan las expresiones FINAL, final, Final, fiNAL, etc.\nfind path -name “nombre” [-print -delete -exec comando {} ; ] Find es un programa mas complejo que los vistos anteriormente. Es mas, en su complejidad, ignora algunos de los puntos de la filosofia de UNIX. Pese a esto, puede llegar a ser bastante util. Aca ensenamos solo una parte, la que consideramos mas util, del uso del programa.\nfind busca en el path dado (osea, en un directorio, incluyendo todos sus subdirectorios) archivos con el nombre dado (en el nombre pueden usarse asteriscos “*” para simbolizar cualquier caracter o combinacion de ellos, o “?” para simbolizar un caracter cualquiera), pero no expresiones regulares. Cada vez que encuentre un archivo con el nombre dado, ejecutara una o mas acciones. Algunas acciones comunes son -print (simplemente imprime en la salida estandar el nombre del archivo encontrado, incluyendo su ubicacion), -delete (borra el archivo encontrado) y -exec.\nEjemplos:\nfind . -name “*.txt” -print Busca archivos que terminen en .txt en el directorio actual y todos sus subdirectorios, imprimiendo el nombre de cada archivo encontrado.\nfind / -name “*calculo*” -delete Busca y borra en todos los directorios (recordar que / contiene a todos los otros directorios) archivos que contengan el la expresion “calculo” en el nombre.\n-exec es una accion compleja. Ejecuta un comando dado cada vez que se encuentra un archivo. Si se quiere entregar el nombre del archivo encontrado al comando, se escribe la expresion “{}” que sera reemplazada por el nombre del archivo encontrado. Al terminar el comando se escibre la expresion “;” El por que son necesarias las barras invertidas (backslash, “\\”) va mas alla de los objetivos de este material).\nEjemplos:\nfind $HOME -name “*.tmp” -exec wc \\{\\} \\; Ejecutara\nwc archivo\npara cada archivo encontrado, por lo que este comando imprimira el numero de palabras de cada archivo que termine en .tmp en el directorio home.\nEs posible combinar varias acciones:\nfind /etc -name “*.conf” -print -exec grep “hostname” \\{\\} \\; Para cada archivo que termine en .conf del directorio /etc (o sus subdirectorios), find imprimira su nombre (accion print) y luego ejecutara grep. El resultado final del comando es que para cada archivo .conf se imprimira su nombre y todas las lineas que contengan la expresion “hostname”.\ntar Aunque en menor medida que find, tar es un comando complejo, que también va contra la filosofía UNIX. Aun asi, es practicamente indispensable. La función de tar es juntar varios archivos en uno solo, y, si se quiere, comprimirlos, de modo de formar el equivalente a un archivo .zip (de hecho, los archivos creados con tar pueden extraerse con WinZip). Para comprimir archivos:\n  tar cvzf nombredearchivocomprimido.tgz patron\n  tar cvjf nombredelarchivocomprimido.tbz patron\n  Las opciones deben darse en el orden indicado.\nEstos dos comandos agregan todos los archivos del directorio actual que calcen con el patron dado a un archivo comprimido. En el primer caso el archivo se comprime con el programa gzip, mientras que en segundo se usa el programa bzip2. El primer programa comprime mas rapido mientras que el segundo logra archivos mas pequenos. Las extensiones son las que se usan convencionalmente para los archivos creados con tar y comprimidos con los respectivos programas. Las extensiones tar.gz y tar.bz2, respectivamente, tambien se utilizan.\nLas opciones son entonces “c”: crear un nuevo archivo, “v”: Imprimir informacion adicional sobre el proceso (puede omitirse), “z” o “j”, indican la herramienta de compresion a utilizar, y f, que va seguido por el nombre del archivo.\nEjemplos:\ntar cvzf geometries.tgz *.xyz Crea el archivo comprimido geometries.tgz que contiene todos los archivos del directorio actual que terminen en .xyz.\ntar cvjf calculation.tbz * crea el archivo comprimido con bzip2 calculations.tbz que contiene a todos los archivos del directorio actual.\nPara descomprimir, simplemente se utiliza la opcion “x” en lugar de “c”.\nEjemplo:\ntar xvjf calculation.tbz Extrae el contenido del archivo calculation.tbz en el directorio actual.\nnohup comando Normalmente, como veremos mas adelante, al cerrar una sesion de shell (por ejemplo, al desconectarnos del computador), todos los programas que estemos ejecutando seran cancelados. Esto puede prevenirse con el comando nohup (no-hang up). Es recomendable utilizarlo con el modificador “\u0026amp;” para que el comando se ejecute en el background, y redirigir la salida del programa a un archivo utilizando “\u0026gt;” . Ejemplo:\nnohup ridft \u0026gt; ridft.out \u0026amp; ssh usuario@computador Inicia una sesion de shell remota en el computador objetivo con el usuario dado. “computador” puede ser una direccion IP o el nombre de un host. ssh pedira un password para el usuario, y si este es correcto, iniciara una sesion de shell en la que el usuario podra usar los comandos vistos en este curso. Toda la conexion es segura (cifrada o encriptada) de ahi el nombre, secure-shell.\nsftp usuario@computador Inicia una sesion de transferencia de archivos con el computador dado. El comando funciona de manera similar a ssh, pero una vez iniciada la sesion los comandos de los que se dispone difieren: Algunos comandos disponibles en una conexion sftp:\n ls: Igual que el comando de UNIX en el computador remoto lls: Igual, pero en el computador local mkdir: Igual que el comando de UNIX, en el computador remoto cd: En el computador remoto lcd: En el computador local pwd: Como el comando de UNIX, muestra el directorio actual en el computador remoto. lpdw: Igual, pero en el computador local. get archivo Baja el archivo dado desde el computador remoto al local put archivo Sube el archivo dado desde el computador local al remoto.  "});index.add({'id':11,'href':'/docencia/docs/estadistica/hidden/','title':"Hidden",'content':"This page is hidden in menu Quondam non pater est dignior ille Eurotas Latent te facies Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "});index.add({'id':12,'href':'/docencia/docs/','title':"Docs",'content':""});})();